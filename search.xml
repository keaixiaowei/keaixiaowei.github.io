<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++标准11-14</title>
      <link href="/2022/07/29/C-%E6%A0%87%E5%87%8611-14/"/>
      <url>/2022/07/29/C-%E6%A0%87%E5%87%8611-14/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲-语言基础-C-x2F-C"><a href="#第一讲-语言基础-C-x2F-C" class="headerlink" title="第一讲 语言基础(C&#x2F;C++)"></a>第一讲 语言基础(C&#x2F;C++)</h1><h2 id="第一节-基础"><a href="#第一节-基础" class="headerlink" title="第一节 基础"></a>第一节 基础</h2><h3 id="1-1-头文件"><a href="#1-1-头文件" class="headerlink" title="1.1 头文件"></a>1.1 头文件</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C1.1.png"></p><p>（1）标准库都在std名称空间中，全名为std::+名字；</p><p>（2）旧版本就是#include&lt;stdio.h&gt;也可以兼容使用；</p><h3 id="1-2-测试是否支持并设置C-2-0-cplusplus"><a href="#1-2-测试是否支持并设置C-2-0-cplusplus" class="headerlink" title="1.2 测试是否支持并设置C++2.0,_cplusplus"></a>1.2 测试是否支持并设置C++2.0,_cplusplus</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C1.2.png"></p><h3 id="1-3-主要学习内容-C-2-0版本"><a href="#1-3-主要学习内容-C-2-0版本" class="headerlink" title="1.3 主要学习内容-C++2.0版本"></a>1.3 主要学习内容-C++2.0版本</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C1.3.png"></p><h2 id="第二节-Variadic-Templates可变参数模板（重量级改变）"><a href="#第二节-Variadic-Templates可变参数模板（重量级改变）" class="headerlink" title="第二节 Variadic Templates可变参数模板（重量级改变）"></a>第二节 Variadic Templates可变参数模板（重量级改变）</h2><h3 id="2-1-print-为例"><a href="#2-1-print-为例" class="headerlink" title="2.1 print()为例"></a>2.1 print()为例</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C2.1.png"></p><p>（1）const Type&amp;… <a href="https://so.csdn.net/so/search?q=args&spm=1001.2101.3001.7020">args</a>表明接收任意数量任意类型的参数；</p><p>（2）可以帮助我们做递归操作每次取出一个参数；做一个递归结束无参数的函数，终止递归；</p><p>（3）sizeof…(args)返回到底有多少个；</p><p>（4）2和3可以并存吗，是可以的！</p><h3 id="2-2-hash-function为例，依次分离出一个参数"><a href="#2-2-hash-function为例，依次分离出一个参数" class="headerlink" title="2.2 hash function为例，依次分离出一个参数"></a>2.2 hash function为例，依次分离出一个参数</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C2.2.png"></p><p>（1）先调用1，形成seed和一包数据，然后调用2（特化)，hash_combine将一包T融入seed变化，然后自己调用自己，再进行拆分，然后到3做为终止条件；每次调用自己的hash_val就是拆分出一个参数；</p><h3 id="2-3-tuple，多次继承为例"><a href="#2-3-tuple，多次继承为例" class="headerlink" title="2.3 tuple，多次继承为例"></a>2.3 tuple，多次继承为例</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C2.3.png"></p><p>（1）每次继承留下一个参数，继承其余一包数据；</p><h2 id="第三节-小改变集合"><a href="#第三节-小改变集合" class="headerlink" title="第三节 小改变集合"></a>第三节 小改变集合</h2><h3 id="3-1-Spaces-in-Template-Expressions模板表达式中的空格"><a href="#3-1-Spaces-in-Template-Expressions模板表达式中的空格" class="headerlink" title="3.1 Spaces in Template Expressions模板表达式中的空格"></a>3.1 Spaces in Template Expressions模板表达式中的空格</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C3.1.png"></p><h3 id="3-2-nullptr"><a href="#3-2-nullptr" class="headerlink" title="3.2 nullptr"></a>3.2 nullptr</h3><p>（1）用nullptr代替0和NULL；空指针；</p><p>（2）nullptr的类型是std::nullptr_t,定义在头文件中；</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C3.2.png"></p><h3 id="3-3-自动类型判断auto"><a href="#3-3-自动类型判断auto" class="headerlink" title="3.3 自动类型判断auto"></a>3.3 自动类型判断auto</h3><p>​(1) 之前auto就是局部变量的意思，但是现在auto表示自动类型判断；</p><p>​(2) 编译器本身就具备自己判断类型的能力；</p><p>​(3) auto关键字</p><p>​(4) 首先判断版本支持C++2.0；标准库本身也在使用auto；</p><p>​(5) 这里是reverse_iterator是迭代器适配器，利用到了迭代器萃取机进行提问回答difference_type的类型作为函数返回类型；</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C3.3.png"></p><h2 id="第四节-Uniform-Initialization一致性的初始化"><a href="#第四节-Uniform-Initialization一致性的初始化" class="headerlink" title="第四节 Uniform Initialization一致性的初始化"></a>第四节 Uniform Initialization一致性的初始化</h2><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.png"></p><p>​(1) 之前的初始化可能用到{},(),&#x3D;赋值；</p><p>​(2) 任意的初始化都可以统一用{}进行初始化，设置初值；</p><p>​(3) 因为编译器遇到{}时会自动生成一个initializer_list,其中T就是int，int,string,double这些，背后 其实是一个array&lt;T,n&gt;,n是元素个数，然后一个一个传给调用的函数（就是int values的构造函数），如果本身接受的就是initial_list,就不用一个一个赋值，直接整个传过去</p><h3 id="4-1-Initializer-list"><a href="#4-1-Initializer-list" class="headerlink" title="4.1 Initializer_list"></a>4.1 Initializer_list</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.1.png"></p><p>​(1) 不允许窄化转换；例如double转int是不被允许的;</p><h3 id="4-2-initializer-list的应用"><a href="#4-2-initializer-list的应用" class="headerlink" title="4.2 initializer_list的应用"></a>4.2 initializer_list的应用</h3><h4 id="4-2-1-例子1"><a href="#4-2-1-例子1" class="headerlink" title="4.2.1 例子1"></a>4.2.1 例子1</h4><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.2(1).png"></p><p>(1) 此处也是对应任意数量的参数，对应生成一个initializer_list，但是注意，这里的类型只能一致指定的int,因为其背后实现是一个array</p><p>数组；和tuple不同，tuple更加强大，任意数量任意类型；</p><p>(2) 这也是应用initializer_list&lt;&gt;的一个方法；</p><h4 id="4-2-2-例子2"><a href="#4-2-2-例子2" class="headerlink" title="4.2.2 例子2"></a>4.2.2 例子2</h4><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.2(2).png"></p><p>(1) 当是complex就调用版本1构造函数；</p><p>(2) 如果没有版本2，q,s还可以使用，因为会被拆解成两个参数，就可以调用版本1，r则不合法操作；</p><p>(3) 右侧是initailizer_list的源代码实现；其data是一个arary的迭代器（指向array的头部），size_type元素个数；编译器可以调用</p><p>initializer_list类private中的一个构造函数，（外部都不可以调用），在看到{}之后就会调用此处，（在调用这个隐私构造函数前，编译器</p><p>会提前创建一个array并把其头迭代器传入此函数参数中）</p><h4 id="4-2-3-array容器新增"><a href="#4-2-3-array容器新增" class="headerlink" title="4.2.3 array容器新增"></a>4.2.3 array容器新增</h4><p>(1) 就可以与STL对接，数组就变成一个容器了，因为算法只跟迭代器对接；</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.2(3).png"></p><h4 id="4-2-4-initializer-list-lt-gt-没有内含array"><a href="#4-2-4-initializer-list-lt-gt-没有内含array" class="headerlink" title="4.2.4 initializer_list&lt;&gt;没有内含array"></a>4.2.4 initializer_list&lt;&gt;没有内含array</h4><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.2(4).png"></p><p>(1)并没有内含着一个array容器，构造函数只是传入一个array迭代器；因此在拷贝的时候，还是相同的元素，传递的只是指针而已（浅拷</p><p>贝）；原来的一包和新的一包指向同一个array；</p><h4 id="4-2-5-initializer-list-lt-gt-在库中应用广泛，说明可以接收数量不定的参数"><a href="#4-2-5-initializer-list-lt-gt-在库中应用广泛，说明可以接收数量不定的参数" class="headerlink" title="4.2.5 initializer_list&lt;&gt;在库中应用广泛，说明可以接收数量不定的参数"></a>4.2.5 initializer_list&lt;&gt;在库中应用广泛，说明可以接收数量不定的参数</h4><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C4.2(5).png"></p><p>(1) 可看到insert传入了{0,1,2,3,4};</p><p>(2) max和min同时比较多个参数，返回其中最大&#x2F;最小的一个参数；</p><h2 id="第五节-explicit关键字—一个以上参数的构造函数"><a href="#第五节-explicit关键字—一个以上参数的构造函数" class="headerlink" title="第五节 explicit关键字—一个以上参数的构造函数"></a>第五节 explicit关键字—一个以上参数的构造函数</h2><h3 id="5-1-C-2-0之前的（只用于一个实参的防止隐式转换）"><a href="#5-1-C-2-0之前的（只用于一个实参的防止隐式转换）" class="headerlink" title="5.1 C++2.0之前的（只用于一个实参的防止隐式转换）"></a>5.1 C++2.0之前的（只用于一个实参的防止隐式转换）</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C5.1.png"></p><p>(1)关键字explicit用于构造函数，用于防止单参数构造函数的隐式转换；只有在明确调用单参数构造函数时，才使用；左侧就会发生隐式转换；</p><h3 id="5-2-C-2-0现在explicit也同样针对于多参数的构造函数的隐式转换"><a href="#5-2-C-2-0现在explicit也同样针对于多参数的构造函数的隐式转换" class="headerlink" title="5.2 C++2.0现在explicit也同样针对于多参数的构造函数的隐式转换"></a>5.2 C++2.0现在explicit也同样针对于多参数的构造函数的隐式转换</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C5.2.png"></p><h2 id="第六节-新特性"><a href="#第六节-新特性" class="headerlink" title="第六节 新特性"></a>第六节 新特性</h2><h3 id="6-1-for循环的一种特殊写法"><a href="#6-1-for循环的一种特殊写法" class="headerlink" title="6.1 for循环的一种特殊写法"></a>6.1 for循环的一种特殊写法</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C6.1.png"></p><p>(1) 之前for()有三段，现在只有两部分，左侧是声明，右侧放容器；</p><p>(2) 第一段是值赋值，如果是复数就是16字节的100万次搬动，下面是auto&amp;引用，因此就是4字节的100万次搬动；而且如果for循环要改变元素的值，一定要用引用，因为上面的只是拷贝到一个新地方，并不影响原来的元素；</p><p>(3) 关联式容器不允许用迭代器改变其元素；</p><h3 id="6-2-for循环的实现—遍历容器一个一个赋值"><a href="#6-2-for循环的实现—遍历容器一个一个赋值" class="headerlink" title="6.2 for循环的实现—遍历容器一个一个赋值"></a>6.2 for循环的实现—遍历容器一个一个赋值</h3><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C6.2(1).png"></p><p>(1) 其实是遍历右侧容器，并将其一个一个赋值到decl中；</p><p>(2) 两种调用，一个是容器的begin()，一个是全局函数begin(容器);</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C2-C++%E6%A0%87%E5%87%8611-14%5C6.2(2).png"></p><p>(3) 左侧C就不允许单参数的隐式转换，因此这种for就会报错；</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将博客推送至github</title>
      <link href="/2022/07/29/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/"/>
      <url>/2022/07/29/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/</url>
      
        <content type="html"><![CDATA[<h2 id="1-本地安装Hexo博客框架并推送到GitHub"><a href="#1-本地安装Hexo博客框架并推送到GitHub" class="headerlink" title="1 本地安装Hexo博客框架并推送到GitHub"></a>1 本地安装Hexo博客框架并推送到GitHub</h2><h3 id="1-1-将博客部署到-github-个人主页上"><a href="#1-1-将博客部署到-github-个人主页上" class="headerlink" title="1.1 将博客部署到 github 个人主页上"></a>1.1 将博客部署到 github 个人主页上</h3><p><strong>第一步：首先登录github，然后新建仓库</strong></p><p>注意：命名格式为：用户名.github.io</p><p><strong>第二步：进入F:\myblog安装一个git的部署部件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p><strong>出现错误：</strong>cnpm安装过程中提示optional install error: Package require os(darwin) not compatible with your platform(win32)</p><p>运行cnpm install后，出现</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(1).png" alt="本地png图片PictureTest.png"></p><p><strong>解决方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm rebuild node-sass</span><br><span class="line">#不放心可以重新安装下</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><p><strong>第三步：在github上创建仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 你的邮箱地址</span><br></pre></td></tr></table></figure><p><strong>第四步：在GitHub 或者 Gitee 上添加 SSH key</strong></p><p>在F:myblog目录下安装 hexo-deployer-git 插件 （git bash here 处安装）</p><p><strong>在github点击头像-&gt;setting</strong></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(2).png" alt="本地png图片PictureTest.png"></p><p><strong>点击SSH and GPG keys</strong></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(3).png" alt="本地png图片PictureTest.png"></p><p><strong>点击New SSH key</strong></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(4).png" alt="本地png图片PictureTest.png"></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(5).png" alt="本地png图片PictureTest.png"></p><p><strong>第五步：测试本机本github密钥对是否建立有效连接：git命令ssh -T github.com，如下返回表示连接成功。</strong></p><p><strong>出现错误：</strong></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(6).png" alt="本地png图片PictureTest.png"></p><p><strong>解决方法：</strong>本机的这个git仓库并没有和这个SSH key 关联上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add &quot;你的 id-rsa 文件地址&quot;</span><br></pre></td></tr></table></figure><p>执行ssh-add “你的 id-rsa 文件地址”出现<strong>Could not open a connection to your authentication agent</strong></p><p><strong>解决方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行如下命令　ssh-agent bash</span><br><span class="line">然后再执行 ssh-add ~/.ssh/id_ras 即可。</span><br></pre></td></tr></table></figure><p><strong>第六步： 修改配置文件_config.yml如下：</strong></p><p><strong>说明：</strong>仓库的ssh链接如下</p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(7).png" alt="本地png图片PictureTest.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: git@github.com:keaixiaowei/keaixiaowei.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><strong>SSH链接</strong></p><p><strong>切记：分支branch切记修改为 main，之前github的默认主分支为master，现已经改为main</strong> ！！！</p><p><strong>第七步：接着hexo clean|hexo g|hexo d就可以远端部署到github上面去啦</strong></p><p><strong>第八步：使用仓库名+.github.io来访问博客主页面。keaixiaowei.github.io</strong></p><p><img src="/img%5C%E5%9B%BE%E7%89%87%5C8%5C1-01(8).png" alt="本地png图片PictureTest.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2022/07/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/07/28/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/28/hello-world/"/>
      <url>/2022/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
